# 인터넷 네트워크
1:1로 통신한다면 우리는 송신 후 OK만 하면 됐는데
인터넷 망이 생기면서 말이 조금 달라졌다

인터넷 망에는 해저케이블도 있을 수 있고, 인공위성을 통한 전달도 있을 수 있을텐데
그렇다면 이 상황에서 어떻게 패킷을 A에서 B로 이동시킬 수 있을까?

인터넷 망에서 어떤 방식으로 패킷이 전달되는가에 대해서는 IP와 프로토콜에 대한 이해가 필요한데 지금부터 이에 대해 학습한다.

## IP

복잡한 인터넷망에서 특정 메세지를 보낸다하면 규칙이 필요한데 (한국 -> 미국)
각각의 IP 어드레스 주소가 부여되어 있어야 한다. (집 주소 부여)

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/D6158E2C-6B46-4AEA-A0C8-3C8B0ACD0709.png)

전송데이터 외부를 나의 IP와 목적지의 IP 2개를 기재/IP 패킷을 만들어서 던진다.


![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/83E78D8B-ABD4-413C-B5A5-F5F420E8D971.png)
아이피패킷에 따라 던지면 서로 200.200.200.2를 쭉 던지면서 찾아질때까지 각 노드가 패킷을 교환한다. 서버에 패킷이 도달하고 나면 같은 방식으로 OK메세지를 보낸다.

### IP 프로토콜의 한계

- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

대상 서버가 살아있는지 확인할 수 없다. 근데 우편불 보내듯 그냥 전송하는 것
중간에 노드에 문제가 생겨서 (꺼짐) 데이터가 유실될 수 있음.

- 비신뢰성 : 패킷이 순서대로 안오거나, 중간에 패킷이 분실되는 경우?

메세지의 용량이 크면 패킷을 쪼개서 보냄
예를 들어
1) Hello
2) World라고 하면 2), 1)로 역순으로 도착할 수도 있음

IP프로토콜만으로는 이 문제 해결이 안됨

- 프로그램 구분 : IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이다?
-> 이 문제들을 해결해주는 것이 TCP 프로토콜이다!

- - - -
## TCP 프로토콜
UDP는 그걸 해결해주지 않지만 도움은(?) 된다.

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/72DBB071-AFFE-4CB6-8CDB-76268B226187.png)

### 프로토콜 계층
![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/84D205AA-1367-417B-9549-C2732EF7DF16.png)
이더넷 프레임? (맥 주소, 실제 물리정보들을 포함시킴)


![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/3C4464D4-A70F-44DA-AB60-2C1D0FD88DDC.png)

TCP 특징 : 전송 제어 프로토콜
1) 연결 지향 - TCP 3 Way HandShaking
2) 데이터 전달 보증
3) 순서 보장

4) 신뢰할 수 있는 프로토콜
-> 대부분 TCP 사용함.

### 3 Way Handshaking
![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/40DB2D97-6CBE-41DA-8125-D33FA64C8560.png)
1) SYN 메세지 전송 (클라이언트 -> 서버)
2) ACK + SYN(나도 연결 해줘) 메세지 전송 (서버 -> 클라이언트)
3) ACK (클라이언트 -> 서버)

둘이 연결이 됐다고 인식한 뒤에 데이터 전송함(연결 안될시 전송 X)

요즘엔 최적화로 ACK랑 같이 데이터 전송함.

이건 개념적으로 연결된 것이고 물리적 연결이 아님.
이건 그냥 그런가보다 논리적으로 판단한 것임.

### 데이터 전달 보증
![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/C0400159-179D-485B-9A60-7A65F7F61A7D.png)

말 그대로, 특정 데이터를 전송했다면 수신지에서 데이터 잘 받았다는 응답을 전송함

### 순서 보장
![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/8221ADED-4534-4474-A5D7-65C2967133DD.png)

질문 : 패킷을 그냥 다 받아서 순서대로 sorting하면 안되나?


## UDP
하얀 도화지에 비유 - 기능이 없음
그냥 IP와 거의 같고 PORT만 추가됨.
1개의 IP에서 여러개의 네트워크 실행된 경우, 프로세스별 PORT 다르게 할당.
CHECKSUM : 이 데이터가 제대로 된게 맞나 검증.

TCP : 3 Way Handshaking, Data 양 많고, 최적화 불가 // 손을 못댐
UDP : 그 위에 내가 원하는 걸 자유롭게 구성할 수 있음

최근에는 UDP 뜨고 있음, HTTP3 TCP 3-Way Handshaking 최적화 원하는게 이유

## PORT
한번에 둘 이상을 연결해야 하면 어떻게 할 것인가?
클라이언트 하나 내에서 게임, 화상통화, 웹 브라우저 요청 3개를 한번에 처리해야하면
클라이언트, 서버간 연결을 여러개 열어야 함.

패킷이 날아올텐데, 어디에서 요청한 패킷인지 어떻게 구분할 것인가? => Port

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/6279F2F0-9818-4106-A4A4-8972BCB01E09.png)

IP = 목적지 서버 / PORT = 동 호수라고 쳐도 될 것 같음.
포트
0 ~.65535 : 할당 가능
0 ~. 1023 : 미리 할당 됨.

## DNS?
IP 숫자 전부 기억하기 어렵고 변경 가능성 다분함.

정의 : IP계의 전화번호부
도메인을 사서 DNS서버에 등록하면 웹 브라우저에서 입력했을때 
DNS서버에서 대응하는 IP주소를 반환함,

## 인터넷 네트워크 정리
인터넷 통신
IP
TCP, UDP
PORT
DNS

## URI(URL)와 웹 브라우저 요청 흐름 정리
- URI(Uniform Resource Identifier)
URI는 로케이터, 이름 또는 둘 다 추가로 분류될 수 있다.
[RFC 3986: Uniform Resource Identifier (URI): Generic Syntax](https://www.rfc-editor.org/rfc/rfc3986)

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/3CC99D17-54D3-4E0D-8A2B-C5DE52B128EF.png)

자원이 어디에 있는지 식별하는 방법에 두가지 방법이 있다.
(Resource Locator) / (Resource name)

For Example
URL : foo :// example.com:8042 / over / there /?name=ferret#nose
        Scheme // authority             /        path        /      query       / fragment

URN : urn:example:animal:ferret:nose

이름을 부여하면 찾기가 어려워져서 주로 URL 사용함
Uniform Resource Identifier
리소스 식별하는 통일된 방식

### URL 전체 문법
![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/8C94809B-293E-4BE7-9719-971E7B911D6F.png)

프로토콜 : https
호스트명 : www.google.com
포트번호 : 443 포트는 주로 생략 가능
패스 : (/search)
쿼리 파라미터 : (q=hello&hl=ko)

userinfo는 거의 사용하지 않음 (url에 사용자 정보 포함해서 인증)


## 웹브라우저 요청 흐름

주소창에 URL 입력하고 딱 ENTER 치는 순간 다음과 같은 HTTP 메세지 생성

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/16575788-03A9-4C20-9039-9F80794C4F66.png)


![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/ABB48350-7A12-45FB-9F42-81A2BE557AD4.png)

패킷이 서버에 도착하면 뚜껑 뜯어서 HTTP 메세지 안에 있는 의미 파싱해서 응답 제작


![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/4016B917-28E2-4A7F-973F-C76C4CF6A12E.png)

똑같이 TCP IP 포장해서 다시 보냄 -> 웹 브라우저가 HTML 렌더링하게 됨.

## HTTP(HyperText Transfer Protocol)
### 모든 것이 HTTP
HTML, TEXT, IMAGE, VIDEO, 음성 영상 파일
JSON, XML, 거의 모든 형태의 데이터 전송 가능
서버간 데이터 주고 받는 경우에도 대부분 HTTP 사용한다

HTTP 1.1 - 가장 중요하고 우리가 많이 사용하는 버전
HTTP/3 - TCP 대신 UDP 사용하고 성능이 개선됨.

### 기반 프로토콜
HTTP/1.1, HTTP / 2 : TCP
HTTP/3 : UDP - 3 way handshaking 최적화

### 클라이언트 서버 구조

Request, Response 구조
클라이언트는 서버에 요청을 보내고 응답을 대기
서버가 요청에 대한 결과를 만들어서 응답함.

분리를 하는게 중요 -> 클라이언트와 서버를 분리해야한다!
비즈니스 로직이랑 데이터는 다 서버에 밀어넣고
클라이언트는 UI, 사용성에만 집중해서 각각 독립적으로 진화할 수 있게 처리

이를 통해, 프론트에서는 그리는것이랑 사용성에만 집중
트래픽이 증가하면 클라이언트 수정 필요없이 상호 독립적으로 구조 개선 가능

### Stateful, Stateless (무상태 프로토콜 지향)
서버가 클라이언트의 상태를 보존하지 않는다
WHAT THE?

#### Stateful(상태 유지)
고객 : 이 노트북 얼마인가요?
점원 : 100만원입니다. ( 노트북 상태 유지 )

고객 : 2개 구매하겠습니다
점원 : 200만원입니다. 현금, 신용카드 중에 어떤걸로 구매하시겠어요?
(노트북, 2개 상태 유지)

고객: 신용카드로 구매하겠습니다.
점원 : 200만원 결제 완료되었습니다.
(노트북, 2개, 신용카드 상태 유지)

#### Stateful(상태 유지) - 중간에 점원이 바뀐다.

고객 : 이 노트북 얼마인가요?
점원 A : 100만원입니다.

고객 : 2개 구매하겠습니다
점원 B : ? 어떤 걸 2개 구매하시겠습니까?

고객: 신용카드로 구매하겠습니다.
점원 C : ? 어떤 제품을 몇개 신용카드로 주문하시겠습니까?

#### Stateless
서버가 클라이언트의 이전 상태 보존 X

고객 : 이 노트북 얼마인가요?
점원 : 100만원입니다.

고객 : 노트북 2개, 구매하겠습니다
점원 : 노트북 2개는 200만원입니다. 신용카드 현금 중에 어떤걸로 구매하시겠어요?

고객 : 노트북 2개 신용카드로 구매하겠습니다.
점원 : 200만원 결제 완료되었습니다.

상태유지 : 중간에 다른 점원으로 바뀌면 안된다
(중간에 다른 점원으로 변하는 경우, 상태 정보를 다른 바뀌는 점원에게 미리 알려줘야 한다)

무상태 : 중간에 다른 점원으로 바뀌어도 된다
갑자기 고객이 증가해도 점원을 대거 투입할 수 있음
갑자기 클라이언트 요청이 증가해도 서버 대거 투입할 수 있음

무상태면 응답서버를 쉽게 바꿀 수 있음

상태유지인 경우 항상 같은 서버와 통신해야 함 (장애 나면 골때려짐)
무상태인 경우 특정 서버가 장애가 나도 다른 서버와 통신 가능.
수평 확장에 유리해 짐. 같은 역할을 하는 서버군의 확장이 가능함.

모든것을 무상태로 설계할 수 있는 경우도 있고 아닌 경우도 있음
-> 로그인 기능 없는 단순 정적 화면은 가능
로그인? -> 쿠키와 서버세션으로 유지(서버에도 유지)
무상태 -> 데이터를 많이 전송해야하는 단점도 있음.


### 비연결성

TCP IP 연결은 기본적으로 연결을 유지하게 됨.
연결을 유지하게 되면 서버 자원이 그만큼 소모되게 된다.

클라이언트 2랑 3이 놀고 있어도 연결이 유지되고 있어야하는 단점 발생.

볼일 끝나면 즉시 연결 끝내버리기 -> 최소한의 자원만 유지하기 때문에 효율적.

HTTP는 기본적으로 연결을 유지하지 않는 모델 (요청 응답은 몇초안에 끝남)
수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십게 이하로 매우 작음

서버 자원을 매우 효율적으로 이용할 수 있어서 좋음.

한계 - TCP/IP 연결을 새로 맺어야 함. 3 Way Handshaking 필요
웹 브라우저로 사이트 요청시 자바스크립트 CSS 이미지 전부 함께 다운로드 됨.

### HTTP 메세지
HTTP는 기본적으로 Persistent Connection 지속 연결로 문제 해결
HTTP2/3에서는 더 많은 최적화 있음


![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/EEA4EE10-B458-4DF2-815E-9DED4582558B.png)
![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/051183D5-F2E4-4E2B-9182-306875561FF5.png)

### 스테이트리스를 기억하자

같은 시간에 딱 맞추어서 발생하는 대용량 트래픽 -> 골때리는 상황 발생
비연결성이 의미가 없음, 명절 KTX

최대한 Stateless하게 설계하자

보통 이벤트 설계하면, 정적페이지 초입에 하나 둔다
사람들이 그 안에서 놀게하고 이벤트 누르도록 유도

## HTTP 메세지 (RFC7230)

### 요청 메세지

시작 라인
헤더
공백(CLRF)
메세지 바디

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/B845D18D-5033-4F84-8C48-CE7243C7A23D.png)

시작 라인
Start-line : **request-line** / status-line
Request-line = 
method SP(공백) request-target SP HTTP-version CLRF(엔터)

HTTP Method
종류 : GET, POST, PUT, DELETE
요청 대상 : 절대경로[?쿼리]
요청 메세지 : HTTP 버전

### 응답 메세지
시작 라인
헤더
공백(CRLF)
메세지 바디 (HTML 주로)

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/84421564-9EBA-488E-9B9E-A5E4EF58F638.png)

시작 라인
Start-line : request-line / **status-line**
Request-line = 
HTTP-version SP **status-code** SP reason-phrase CRLF

HTTP 버전
HTTP 상태코드
이유문구

### HTTP 헤더
![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/8A73256B-1791-4DAE-8AF2-C20DA93D4D1C.png)
용도 : HTTP 전송에 필요한 모든 부가정보
메세지 바디의 내용 크기 압축 인증 요청 클라이언트 정보 서버 앱 정보 캐시 관리 정보 등 각종 메타데이터 전부 속해있음


### HTTP 메세지 바디 - 실제 전송할 데이터
HTML 문서, 이미지 ,영상, JSON 등 각종 문서 들어가 있음.

### HTTP API 만들어보기
URI 설계의 핵심은 리소스 식별!

회원을 등록, 수정, 조회하는게 리소스가 아니라
회원이라는 개념 자체가 리소스임

회원 등록, 수정, 조회를 모두 배제하고 리소스만 식별하기
회원 리소스를 URI에 매핑

![](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%82%E1%85%A6%E1%86%BA%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3/760014DE-831B-48B7-9025-A43B59912B4A.png)

리소스와 행위을 분리 가장 중요한 것은 리소스를 식별하는 것
﻿﻿
URI는 리소스만 식별!
﻿﻿
리소스와 해당 리소스를 대상으로 하는 행위을 분리
﻿﻿
리소스: 회원
﻿﻿
행위: 조회, 등록, 삭제, 변경
﻿﻿
리소스는 명사, 행위는 동사 (미네랄을 캐라)
﻿﻿
행위(메서드)는 어떻게 구분? 

